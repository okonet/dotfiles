{
  "source": "doc/api/buffer.markdown",
  "modules": [
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>Pure JavaScript is Unicode friendly but not nice to binary data.  When\ndealing with TCP streams or the file system, it&#39;s necessary to handle octet\nstreams. io.js has several strategies for manipulating, creating, and\nconsuming octet streams.\n\n</p>\n<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar\nto an array of integers but corresponds to a raw memory allocation outside\nthe V8 heap. A <code>Buffer</code> cannot be resized.\n\n</p>\n<p>The <code>Buffer</code> class is a global, making it very rare that one would need\nto ever <code>require(&#39;buffer&#39;)</code>.\n\n</p>\n<p>Converting between Buffers and JavaScript string objects requires an explicit\nencoding method.  Here are the different string encodings.\n\n</p>\n<ul>\n<li><p><code>&#39;ascii&#39;</code> - for 7 bit ASCII data only.  This encoding method is very fast, and\nwill strip the high bit if set.</p>\n</li>\n<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other\ndocument formats use UTF-8.</p>\n</li>\n<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little endian encoded Unicode characters.\nSurrogate pairs (U+10000 to U+10FFFF) are supported.</p>\n</li>\n<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>\n</li>\n<li><p><code>&#39;base64&#39;</code> - Base64 string encoding.</p>\n</li>\n<li><p><code>&#39;binary&#39;</code> - A way of encoding raw binary data into strings by using only\nthe first 8 bits of each character. This encoding method is deprecated and\nshould be avoided in favor of <code>Buffer</code> objects where possible. This encoding\nwill be removed in future versions of io.js.</p>\n</li>\n<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>\n</li>\n</ul>\n<p>Creating a typed array from a <code>Buffer</code> works with the following caveats:\n\n</p>\n<ol>\n<li><p>The buffer&#39;s memory is copied, not shared.</p>\n</li>\n<li><p>The buffer&#39;s memory is interpreted as an array, not a byte array.  That is,\n<code>new Uint32Array(new Buffer([1,2,3,4]))</code> creates a 4-element <code>Uint32Array</code>\nwith elements <code>[1,2,3,4]</code>, not an <code>Uint32Array</code> with a single element\n<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>\n</li>\n</ol>\n<p>NOTE: Node.js v0.8 simply retained a reference to the buffer in <code>array.buffer</code>\ninstead of cloning it.\n\n</p>\n<p>While more efficient, it introduces subtle incompatibilities with the typed\narrays specification.  <code>ArrayBuffer#slice()</code> makes a copy of the slice while\n<code>Buffer#slice()</code> creates a view.\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<p>The Buffer class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.\n\n</p>\n",
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.isEncoding(encoding)",
              "type": "classMethod",
              "name": "isEncoding",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`encoding` {String} The encoding string to test ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The encoding string to test"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns true if the <code>encoding</code> is a valid encoding argument, or false\notherwise.\n\n</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Boolean ",
                    "name": "return",
                    "desc": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` Object ",
                      "name": "obj",
                      "desc": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ],
              "desc": "<p>Tests if <code>obj</code> is a <code>Buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string[, encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`string` String ",
                      "name": "string",
                      "desc": "String"
                    },
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Gives the actual byte length of a string. <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.\nThis is not the same as <code>String.prototype.length</code> since that returns the\nnumber of <em>characters</em> in a string.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>str = &#39;\\u00bd + \\u00bc = \\u00be&#39;;\n\nconsole.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +\n  Buffer.byteLength(str, &#39;utf8&#39;) + &quot; bytes&quot;);\n\n// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.concat(list[, totalLength])",
              "type": "classMethod",
              "name": "concat",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`list` {Array} List of Buffer objects to concat ",
                      "name": "list",
                      "type": "Array",
                      "desc": "List of Buffer objects to concat"
                    },
                    {
                      "textRaw": "`totalLength` {Number} Total length of the buffers when concatenated ",
                      "name": "totalLength",
                      "type": "Number",
                      "desc": "Total length of the buffers when concatenated",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "list"
                    },
                    {
                      "name": "totalLength",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a buffer which is the result of concatenating all the buffers in\nthe list together.\n\n</p>\n<p>If the list has no items, or if the totalLength is 0, then it returns a\nzero-length buffer.\n\n</p>\n<p>If the list has exactly one item, then the first item of the list is\nreturned.\n\n</p>\n<p>If the list has more than one item, then a new Buffer is created.\n\n</p>\n<p>If totalLength is not provided, it is read from the buffers in the list.\nHowever, this adds an additional loop to the function, so it is faster\nto provide the length explicitly.\n\n</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.compare(buf1, buf2)",
              "type": "classMethod",
              "name": "compare",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buf1` {Buffer} ",
                      "name": "buf1",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`buf2` {Buffer} ",
                      "name": "buf2",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf1"
                    },
                    {
                      "name": "buf2"
                    }
                  ]
                }
              ],
              "desc": "<p>The same as <a href=\"#buffer_buf_compare_otherbuffer\"><code>buf1.compare(buf2)</code></a>. Useful\nfor sorting an Array of Buffers:\n\n</p>\n<pre><code>var arr = [Buffer(&#39;1234&#39;), Buffer(&#39;0123&#39;)];\narr.sort(Buffer.compare);</code></pre>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`length` Number ",
              "name": "length",
              "desc": "<p>The size of the buffer in bytes.  Note that this is not necessarily the size\nof the contents. <code>length</code> refers to the amount of memory allocated for the\nbuffer object.  It does not change when the contents of the buffer are changed.\n\n</p>\n<pre><code>buf = new Buffer(1234);\n\nconsole.log(buf.length);\nbuf.write(&quot;some string&quot;, 0, &quot;ascii&quot;);\nconsole.log(buf.length);\n\n// 1234\n// 1234</code></pre>\n<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>\ncan result in undefined and inconsistent behavior. Applications that wish to\nmodify the length of a buffer should therefore treat <code>length</code> as read-only and\nuse <code>buf.slice</code> to create a new buffer.\n\n</p>\n<pre><code>buf = new Buffer(10);\nbuf.write(&quot;abcdefghj&quot;, 0, &quot;ascii&quot;);\nconsole.log(buf.length); // 10\nbuf = buf.slice(0,5);\nconsole.log(buf.length); // 5</code></pre>\n",
              "shortDesc": "Number"
            },
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "desc": "<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,\nso the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.\n\n</p>\n<p>Example: copy an ASCII string into a buffer, one byte at a time:\n\n</p>\n<pre><code>str = &quot;io.js&quot;;\nbuf = new Buffer(str.length);\n\nfor (var i = 0; i &lt; str.length ; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf);\n\n// io.js</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "buf.write(string[, offset][, length][, encoding])",
              "type": "method",
              "name": "write",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` String - data to be written to buffer ",
                      "name": "string",
                      "desc": "String - data to be written to buffer"
                    },
                    {
                      "textRaw": "`offset` Number, Optional, Default: 0 ",
                      "name": "offset",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` Number, Optional, Default: `buffer.length - offset` ",
                      "name": "length",
                      "desc": "Number, Optional, Default: `buffer.length - offset`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding.\n<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>. <code>length</code> is\nthe number of bytes to write. Returns number of octets written. If <code>buffer</code> did\nnot contain enough space to fit the entire string, it will write a partial\namount of the string. <code>length</code> defaults to <code>buffer.length - offset</code>.\nThe method will not write partial characters.\n\n</p>\n<pre><code>buf = new Buffer(256);\nlen = buf.write(&#39;\\u00bd + \\u00bc = \\u00be&#39;, 0);\nconsole.log(len + &quot; bytes: &quot; + buf.toString(&#39;utf8&#39;, 0, len));</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntLE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified <code>offset</code> and <code>byteLength</code>.\nSupports up to 48 bits of accuracy. For example:\n\n</p>\n<pre><code>var b = new Buffer(6);\nb.writeUIntBE(0x1234567890ab, 0, 6);\n// &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>\n<p>Set <code>noAssert</code> to <code>true</code> to skip validation of <code>value</code> and <code>offset</code>. Defaults\nto <code>false</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeIntBE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Bytes to be written to buffer ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Bytes to be written to buffer"
                    },
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified <code>offset</code> and <code>byteLength</code>.\nSupports up to 48 bits of accuracy. For example:\n\n</p>\n<pre><code>var b = new Buffer(6);\nb.writeUIntBE(0x1234567890ab, 0, 6);\n// &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>\n<p>Set <code>noAssert</code> to <code>true</code> to skip validation of <code>value</code> and <code>offset</code>. Defaults\nto <code>false</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readIntLE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>A generalized version of all numeric read methods. Supports up to 48 bits of\naccuracy. For example:\n\n</p>\n<pre><code>var b = new Buffer(6);\nb.writeUint16LE(0x90ab, 0);\nb.writeUInt32LE(0x12345678, 2);\nb.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)\n// output: &#39;1234567890ab&#39;</code></pre>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readIntBE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Number} `0 <= offset <= buf.length` ",
                      "name": "offset",
                      "type": "Number",
                      "desc": "`0 <= offset <= buf.length`"
                    },
                    {
                      "textRaw": "`byteLength` {Number} `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Number",
                      "desc": "`0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Default: false ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>A generalized version of all numeric read methods. Supports up to 48 bits of\naccuracy. For example:\n\n</p>\n<pre><code>var b = new Buffer(6);\nb.writeUint16LE(0x90ab, 0);\nb.writeUInt32LE(0x12345678, 2);\nb.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)\n// output: &#39;1234567890ab&#39;</code></pre>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.toString([encoding][, start][, end])",
              "type": "method",
              "name": "toString",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` Number, Optional, Default: 0 ",
                      "name": "start",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` Number, Optional, Default: `buffer.length` ",
                      "name": "end",
                      "desc": "Number, Optional, Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes and returns a string from buffer data encoded using the specified\ncharacter set encoding. If <code>encoding</code> is <code>undefined</code> or <code>null</code>, then <code>encoding</code>\ndefaults to <code>&#39;utf8&#39;. The </code>start<code> and </code>end<code> parameters default to </code>0<code> and\n</code>buffer.length<code> when </code>undefined`.\n\n</p>\n<pre><code>buf = new Buffer(26);\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf[i] = i + 97; // 97 is ASCII a\n}\nbuf.toString(&#39;ascii&#39;); // outputs: abcdefghijklmnopqrstuvwxyz\nbuf.toString(&#39;ascii&#39;,0,5); // outputs: abcde\nbuf.toString(&#39;utf8&#39;,0,5); // outputs: abcde\nbuf.toString(undefined,0,5); // encoding defaults to &#39;utf8&#39;, outputs abcde</code></pre>\n<p>See <code>buffer.write()</code> example, above.\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.toJSON()",
              "type": "method",
              "name": "toJSON",
              "desc": "<p>Returns a JSON-representation of the Buffer instance.  <code>JSON.stringify</code>\nimplicitly calls this function when stringifying a Buffer instance.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(&#39;test&#39;);\nvar json = JSON.stringify(buf);\n\nconsole.log(json);\n// &#39;{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[116,101,115,116]}&#39;\n\nvar copy = JSON.parse(json, function(key, value) {\n    return value &amp;&amp; value.type === &#39;Buffer&#39;\n      ? new Buffer(value.data)\n      : value;\n  });\n\nconsole.log(copy);\n// &lt;Buffer 74 65 73 74&gt;</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "buf.equals(otherBuffer)",
              "type": "method",
              "name": "equals",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} ",
                      "name": "otherBuffer",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "otherBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a boolean of whether <code>this</code> and <code>otherBuffer</code> have the same\nbytes.\n\n</p>\n"
            },
            {
              "textRaw": "buf.compare(otherBuffer)",
              "type": "method",
              "name": "compare",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} ",
                      "name": "otherBuffer",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "otherBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a number indicating whether <code>this</code> comes before or after or is\nthe same as the <code>otherBuffer</code> in sort order.\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])",
              "type": "method",
              "name": "copy",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`targetBuffer` Buffer object - Buffer to copy into ",
                      "name": "targetBuffer",
                      "desc": "Buffer object - Buffer to copy into"
                    },
                    {
                      "textRaw": "`targetStart` Number, Optional, Default: 0 ",
                      "name": "targetStart",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` Number, Optional, Default: 0 ",
                      "name": "sourceStart",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` Number, Optional, Default: `buffer.length` ",
                      "name": "sourceEnd",
                      "desc": "Number, Optional, Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "targetBuffer"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Copies data from a region of this buffer to a region in the target buffer even\nif the target memory region overlaps with the source. If <code>undefined</code> the\n<code>targetStart</code> and <code>sourceStart</code> parameters default to <code>0</code> while <code>sourceEnd</code>\ndefaults to <code>buffer.length</code>.\n\n</p>\n<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19\ninto <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.\n\n</p>\n<pre><code>buf1 = new Buffer(26);\nbuf2 = new Buffer(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n  buf2[i] = 33; // ASCII !\n}\n\nbuf1.copy(buf2, 8, 16, 20);\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, 25));\n\n// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>\n<p>Example: Build a single buffer, then copy data from one region to an overlapping\nregion in the same buffer\n\n</p>\n<pre><code>buf = new Buffer(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf[i] = i + 97; // 97 is ASCII a\n}\n\nbuf.copy(buf, 0, 4, 10);\nconsole.log(buf.toString());\n\n// efghijghijklmnopqrstuvwxyz</code></pre>\n"
            },
            {
              "textRaw": "buf.slice([start][, end])",
              "type": "method",
              "name": "slice",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`start` Number, Optional, Default: 0 ",
                      "name": "start",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` Number, Optional, Default: `buffer.length` ",
                      "name": "end",
                      "desc": "Number, Optional, Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new buffer which references the same memory as the old, but offset\nand cropped by the <code>start</code> (defaults to <code>0</code>) and <code>end</code> (defaults to\n<code>buffer.length</code>) indexes.  Negative indexes start from the end of the buffer.\n\n</p>\n<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong>\n\n</p>\n<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one\nbyte from the original Buffer.\n\n</p>\n<pre><code>var buf1 = new Buffer(26);\n\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n}\n\nvar buf2 = buf1.slice(0, 3);\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\nbuf1[0] = 33;\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\n\n// abc\n// !bc</code></pre>\n"
            },
            {
              "textRaw": "buf.indexOf(value[, byteOffset])",
              "type": "method",
              "name": "indexOf",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`value` String, Buffer or Number ",
                      "name": "value",
                      "desc": "String, Buffer or Number"
                    },
                    {
                      "textRaw": "`byteOffset` Number, Optional, Default: 0 ",
                      "name": "byteOffset",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Operates similar to\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\">Array#indexOf()</a>.\nAccepts a String, Buffer or Number. Strings are interpreted as UTF8. Buffers\nwill use the entire buffer. So in order to compare a partial Buffer use\n<code>Buffer#slice()</code>. Numbers can range from 0 to 255.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readUInt8(offset[, noAssert])",
              "type": "method",
              "name": "readUInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nfor (ii = 0; ii &lt; buf.length; ii++) {\n  console.log(buf.readUInt8(ii));\n}\n\n// 0x3\n// 0x4\n// 0x23\n// 0x42</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt16BE(0));\nconsole.log(buf.readUInt16LE(0));\nconsole.log(buf.readUInt16BE(1));\nconsole.log(buf.readUInt16LE(1));\nconsole.log(buf.readUInt16BE(2));\nconsole.log(buf.readUInt16LE(2));\n\n// 0x0304\n// 0x0403\n// 0x0423\n// 0x2304\n// 0x2342\n// 0x4223</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt16BE(0));\nconsole.log(buf.readUInt16LE(0));\nconsole.log(buf.readUInt16BE(1));\nconsole.log(buf.readUInt16LE(1));\nconsole.log(buf.readUInt16BE(2));\nconsole.log(buf.readUInt16LE(2));\n\n// 0x0304\n// 0x0403\n// 0x0423\n// 0x2304\n// 0x2342\n// 0x4223</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt32BE(0));\nconsole.log(buf.readUInt32LE(0));\n\n// 0x03042342\n// 0x42230403</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt32BE(0));\nconsole.log(buf.readUInt32LE(0));\n\n// 0x03042342\n// 0x42230403</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt8(offset[, noAssert])",
              "type": "method",
              "name": "readInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 8 bit integer from the buffer at the specified offset.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&#39;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&#39;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&#39;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&#39;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&#39;s\ncomplement signed values.\n\n</p>\n"
            },
            {
              "textRaw": "buf.readFloatLE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32 bit float from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x00;\nbuf[1] = 0x00;\nbuf[2] = 0x80;\nbuf[3] = 0x3f;\n\nconsole.log(buf.readFloatLE(0));\n\n// 0x01</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatBE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32 bit float from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x00;\nbuf[1] = 0x00;\nbuf[2] = 0x80;\nbuf[3] = 0x3f;\n\nconsole.log(buf.readFloatLE(0));\n\n// 0x01</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleLE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64 bit double from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\n\nbuf[0] = 0x55;\nbuf[1] = 0x55;\nbuf[2] = 0x55;\nbuf[3] = 0x55;\nbuf[4] = 0x55;\nbuf[5] = 0x55;\nbuf[6] = 0xd5;\nbuf[7] = 0x3f;\n\nconsole.log(buf.readDoubleLE(0));\n\n// 0.3333333333333333</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleBE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64 bit double from the buffer at the specified offset with specified\nendian format.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\n\nbuf[0] = 0x55;\nbuf[1] = 0x55;\nbuf[2] = 0x55;\nbuf[3] = 0x55;\nbuf[4] = 0x55;\nbuf[5] = 0x55;\nbuf[6] = 0xd5;\nbuf[7] = 0x3f;\n\nconsole.log(buf.readDoubleLE(0));\n\n// 0.3333333333333333</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt8",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a\nvalid unsigned 8 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n\n// &lt;Buffer 03 04 23 42&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n\n// &lt;Buffer de ad be ef&gt;\n// &lt;Buffer ad de ef be&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n\n// &lt;Buffer de ad be ef&gt;\n// &lt;Buffer ad de ef be&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer fe ed fa ce&gt;\n// &lt;Buffer ce fa ed fe&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid unsigned 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer fe ed fa ce&gt;\n// &lt;Buffer ce fa ed fe&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt8",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a\nvalid signed 8 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&#39;s complement\nsigned integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&#39;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 16 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&#39;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&#39;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid signed 32 bit integer.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&#39;s\ncomplement signed integer into <code>buffer</code>.\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatLE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, behavior is unspecified if <code>value</code> is not a 32 bit float.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 4f 4a fe bb&gt;\n// &lt;Buffer bb fe 4a 4f&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatBE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, behavior is unspecified if <code>value</code> is not a 32 bit float.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 4f 4a fe bb&gt;\n// &lt;Buffer bb fe 4a 4f&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleLE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid 64 bit double.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleBE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\nformat. Note, <code>value</code> must be a valid 64 bit double.\n\n</p>\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\n\n</p>\n<p>Example:\n\n</p>\n<pre><code>var buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\n// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>\n"
            },
            {
              "textRaw": "buf.fill(value[, offset][, end])",
              "type": "method",
              "name": "fill",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` ",
                      "name": "value"
                    },
                    {
                      "textRaw": "`offset` Number, Optional ",
                      "name": "offset",
                      "optional": true,
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`end` Number, Optional ",
                      "name": "end",
                      "optional": true,
                      "desc": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)\nand <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire\nbuffer.\n\n</p>\n<pre><code>var b = new Buffer(50);\nb.fill(&quot;h&quot;);</code></pre>\n"
            },
            {
              "textRaw": "buffer.values()",
              "type": "method",
              "name": "values",
              "desc": "<p>Creates iterator for buffer values (bytes). This function is called automatically\nwhen <code>buffer</code> is used in a <code>for..of</code> statement.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "buffer.keys()",
              "type": "method",
              "name": "keys",
              "desc": "<p>Creates iterator for buffer keys (indices).\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "buffer.entries()",
              "type": "method",
              "name": "entries",
              "desc": "<p>Creates iterator for <code>[index, byte]</code> arrays.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` Number ",
                  "name": "size",
                  "desc": "Number"
                }
              ],
              "desc": "<p>Allocates a new buffer of <code>size</code> octets. Note, <code>size</code> must be no more than\n<a href=\"smalloc.html#smalloc_smalloc_kmaxlength\">kMaxLength</a>. Otherwise, a <code>RangeError</code>\nwill be thrown here.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Allocates a new buffer of <code>size</code> octets. Note, <code>size</code> must be no more than\n<a href=\"smalloc.html#smalloc_smalloc_kmaxlength\">kMaxLength</a>. Otherwise, a <code>RangeError</code>\nwill be thrown here.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`array` Array ",
                  "name": "array",
                  "desc": "Array"
                }
              ],
              "desc": "<p>Allocates a new buffer using an <code>array</code> of octets.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "array"
                }
              ],
              "desc": "<p>Allocates a new buffer using an <code>array</code> of octets.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`buffer` {Buffer} ",
                  "name": "buffer",
                  "type": "Buffer"
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "buffer"
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`str` String - string to encode. ",
                  "name": "str",
                  "desc": "String - string to encode."
                },
                {
                  "textRaw": "`encoding` String - encoding to use, Optional. ",
                  "name": "encoding",
                  "desc": "String - encoding to use, Optional.",
                  "optional": true
                }
              ],
              "desc": "<p>Allocates a new buffer containing the given <code>str</code>.\n<code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ],
              "desc": "<p>Allocates a new buffer containing the given <code>str</code>.\n<code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "desc": "<p>Returns an un-pooled <code>Buffer</code>.\n\n</p>\n<p>In order to avoid the garbage collection overhead of creating many individually\nallocated Buffers, by default allocations under 4KB are sliced from a single\nlarger allocated object. This approach improves both performance and memory\nusage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.\n\n</p>\n<p>In the case where a developer may need to retain a small chunk of memory from a\npool for an indeterminate amount of time it may be appropriate to create an\nun-pooled Buffer instance using SlowBuffer and copy out the relevant bits.\n\n</p>\n<pre><code>// need to keep around a few small chunks of memory\nvar store = [];\n\nsocket.on(&#39;readable&#39;, function() {\n  var data = socket.read();\n  // allocate for retained data\n  var sb = new SlowBuffer(10);\n  // copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n  store.push(sb);\n});</code></pre>\n<p>Though this should be used sparingly and only be a last resort <em>after</em> a developer\nhas actively observed undue memory retention in their applications.\n</p>\n"
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` Number, Default: 50 ",
          "name": "INSPECT_MAX_BYTES",
          "desc": "<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can\nbe overridden by user modules.\n\n</p>\n<p>Note that this is a property on the buffer module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the Buffer global, or a buffer instance.\n\n</p>\n",
          "shortDesc": "Number, Default: 50"
        }
      ],
      "modules": [
        {
          "textRaw": "ES6 iteration",
          "name": "es6_iteration",
          "desc": "<p>Buffers can be iterated over using <code>for..of</code> syntax:\n\n</p>\n<pre><code>var buf = new Buffer([1, 2, 3]);\n\nfor (var b of buf)\n  console.log(b)\n\n// 1\n// 2\n// 3</code></pre>\n<p>Additionally, <code>buffer.values()</code>, <code>buffer.keys()</code> and <code>buffer.entries()</code>\nmethods can be used to create iterators.\n\n</p>\n",
          "type": "module",
          "displayName": "ES6 iteration"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    }
  ]
}
