=begin
 This is a machine generated stub using stdlib-doc for <b>class Proc</b>
 Sources used:  Ruby 1.9.2-p290
 Created on 2014-03-18 09:08:36 +0400 by IntelliJ Ruby Stubs Generator.
=end

# <code>Proc</code> objects are blocks of code that have been bound to
# a set of local variables. Once bound, the code may be called in
# different contexts and still access those variables.
# 
#    def gen_times(factor)
#      return Proc.new {|n| n*factor }
#    end
# 
#    times3 = gen_times(3)
#    times5 = gen_times(5)
# 
#    times3.call(12)               #=> 36
#    times5.call(5)                #=> 25
#    times3.call(times5.call(4))   #=> 60
class Proc
    # Proc.new {|...| block } -> a_proc
    # Proc.new                -> a_proc
    #  
    # Creates a new <code>Proc</code> object, bound to the current
    # context. <code>Proc::new</code> may be called without a block only
    # within a method with an attached block, in which case that block is
    # converted to the <code>Proc</code> object.
    # 
    #    def proc_from
    #      Proc.new
    #    end
    #    proc = proc_from { "hello" }
    #    proc.call   #=> "hello"
    def self.new(*several_variants)
        #This is a stub, used for indexing
    end
    # prc === obj   -> result_of_proc
    #  
    # Invokes the block, with <i>obj</i> as the block's parameter.  It is
    # to allow a proc object to be a target of +when+ clause in the case statement.
    def call(*args)
        #This is a stub, used for indexing
    end
    # prc === obj   -> result_of_proc
    #  
    # Invokes the block, with <i>obj</i> as the block's parameter.  It is
    # to allow a proc object to be a target of +when+ clause in the case statement.
    def [](*args)
        #This is a stub, used for indexing
    end
    # prc === obj   -> result_of_proc
    #  
    # Invokes the block, with <i>obj</i> as the block's parameter.  It is
    # to allow a proc object to be a target of +when+ clause in the case statement.
    def === obj
        #This is a stub, used for indexing
    end
    # prc === obj   -> result_of_proc
    #  
    # Invokes the block, with <i>obj</i> as the block's parameter.  It is
    # to allow a proc object to be a target of +when+ clause in the case statement.
    def yield(*args)
        #This is a stub, used for indexing
    end
    # prc.to_proc -> prc
    #  
    # Part of the protocol for converting objects to <code>Proc</code>
    # objects. Instances of class <code>Proc</code> simply return
    # themselves.
    def to_proc()
        #This is a stub, used for indexing
    end
    # prc.arity -> fixnum
    #  
    # Returns the number of arguments that would not be ignored. If the block
    # is declared to take no arguments, returns 0. If the block is known
    # to take exactly n arguments, returns n. If the block has optional
    # arguments, return -n-1, where n is the number of mandatory
    # arguments. A <code>proc</code> with no argument declarations
    # is the same a block declaring <code>||</code> as its arguments.
    # 
    #    Proc.new {}.arity          #=>  0
    #    Proc.new {||}.arity        #=>  0
    #    Proc.new {|a|}.arity       #=>  1
    #    Proc.new {|a,b|}.arity     #=>  2
    #    Proc.new {|a,b,c|}.arity   #=>  3
    #    Proc.new {|*a|}.arity      #=> -1
    #    Proc.new {|a,*b|}.arity    #=> -2
    #    Proc.new {|a,*b, c|}.arity    #=> -3
    def arity()
        #This is a stub, used for indexing
    end
    # prc == other_proc   ->  true or false
    #  
    # Return <code>true</code> if <i>prc</i> is the same object as
    # <i>other_proc</i>, or if they are both procs with the same body.
    def == other_proc
        #This is a stub, used for indexing
    end
    # prc == other_proc   ->  true or false
    #  
    # Return <code>true</code> if <i>prc</i> is the same object as
    # <i>other_proc</i>, or if they are both procs with the same body.
    def eql?(p1)
        #This is a stub, used for indexing
    end
    # prc.hash   ->  integer
    #  
    # Return hash value corresponding to proc body.
    def hash()
        #This is a stub, used for indexing
    end
    # prc.to_s   -> string
    #  
    # Shows the unique identifier for this proc, along with
    # an indication of where the proc was defined.
    def to_s()
        #This is a stub, used for indexing
    end
    # prc.lambda? -> true or false
    #  
    # Returns true for a Proc object which argument handling is rigid.
    # Such procs are typically generated by lambda.
    # 
    # A Proc object generated by proc ignore extra arguments.
    # 
    #   proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]
    # 
    # It provides nil for lacked arguments.
    # 
    #   proc {|a,b| [a,b] }.call(1)        #=> [1,nil]
    # 
    # It expand single-array argument.
    # 
    #   proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]
    # 
    # A Proc object generated by lambda doesn't have such tricks.
    # 
    #   lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError
    #   lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError
    #   lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError
    # 
    # Proc#lambda? is a predicate for the tricks.
    # It returns true if no tricks.
    # 
    #   lambda {}.lambda?            #=> true
    #   proc {}.lambda?              #=> false
    # 
    # Proc.new is same as proc.
    # 
    #   Proc.new {}.lambda?          #=> false
    # 
    # lambda, proc and Proc.new preserves the tricks of
    # a Proc object given by & argument.
    # 
    #   lambda(&lambda {}).lambda?   #=> true
    #   proc(&lambda {}).lambda?     #=> true
    #   Proc.new(&lambda {}).lambda? #=> true
    # 
    #   lambda(&proc {}).lambda?     #=> false
    #   proc(&proc {}).lambda?       #=> false
    #   Proc.new(&proc {}).lambda?   #=> false
    # 
    # A Proc object generated by & argument has the tricks
    # 
    #   def n(&b) b.lambda? end
    #   n {}                         #=> false
    # 
    # The & argument preserves the tricks if a Proc object is given
    # by & argument.
    # 
    #   n(&lambda {})                #=> true
    #   n(&proc {})                  #=> false
    #   n(&Proc.new {})              #=> false
    # 
    # A Proc object converted from a method has no tricks.
    # 
    #   def m() end
    #   method(:m).to_proc.lambda?   #=> true
    # 
    #   n(&method(:m))               #=> true
    #   n(&method(:m).to_proc)       #=> true
    # 
    # define_method is treated same as method definition.
    # The defined method has no tricks.
    # 
    #   class C
    #     define_method(:d) {}
    #   end
    #   C.new.e(1,2)       #=> ArgumentError
    #   C.new.method(:d).to_proc.lambda?   #=> true
    # 
    # define_method always defines a method without the tricks,
    # even if a non-lambda Proc object is given.
    # This is the only exception which the tricks are not preserved.
    # 
    #   class C
    #     define_method(:e, &proc {})
    #   end
    #   C.new.e(1,2)       #=> ArgumentError
    #   C.new.method(:e).to_proc.lambda?   #=> true
    # 
    # This exception is for a wrapper of define_method.
    # It eases defining a method defining method which defines a usual method which has no tricks.
    # 
    #   class << C
    #     def def2(name, &body)
    #       define_method(name, &body)
    #     end
    #   end
    #   class C
    #     def2(:f) {}
    #   end
    #   C.new.f(1,2)       #=> ArgumentError
    # 
    # The wrapper, def2, defines a method which has no tricks.
    def lambda?()
        #This is a stub, used for indexing
    end
    # prc.binding    -> binding
    #  
    # Returns the binding associated with <i>prc</i>. Note that
    # <code>Kernel#eval</code> accepts either a <code>Proc</code> or a
    # <code>Binding</code> object as its second parameter.
    # 
    #    def fred(param)
    #      proc {}
    #    end
    # 
    #    b = fred(99)
    #    eval("param", b.binding)   #=> 99
    def binding()
        #This is a stub, used for indexing
    end
    # prc.curry         -> a_proc
    # prc.curry(arity)  -> a_proc
    #  
    # Returns a curried proc. If the optional <i>arity</i> argument is given,
    # it determines the number of arguments.
    # A curried proc receives some arguments. If a sufficient number of
    # arguments are supplied, it passes the supplied arguments to the original
    # proc and returns the result. Otherwise, returns another curried proc that
    # takes the rest of arguments.
    # 
    #    b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
    #    p b.curry[1][2][3]           #=> 6
    #    p b.curry[1, 2][3, 4]        #=> 6
    #    p b.curry(5)[1][2][3][4][5]  #=> 6
    #    p b.curry(5)[1, 2][3, 4][5]  #=> 6
    #    p b.curry(1)[1]              #=> 1
    # 
    #    b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
    #    p b.curry[1][2][3]           #=> 6
    #    p b.curry[1, 2][3, 4]        #=> 10
    #    p b.curry(5)[1][2][3][4][5]  #=> 15
    #    p b.curry(5)[1, 2][3, 4][5]  #=> 15
    #    p b.curry(1)[1]              #=> 1
    # 
    #    b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
    #    p b.curry[1][2][3]           #=> 6
    #    p b.curry[1, 2][3, 4]        #=> wrong number of arguments (4 for 3)
    #    p b.curry(5)                 #=> wrong number of arguments (5 for 3)
    #    p b.curry(1)                 #=> wrong number of arguments (1 for 3)
    # 
    #    b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
    #    p b.curry[1][2][3]           #=> 6
    #    p b.curry[1, 2][3, 4]        #=> 10
    #    p b.curry(5)[1][2][3][4][5]  #=> 15
    #    p b.curry(5)[1, 2][3, 4][5]  #=> 15
    #    p b.curry(1)                 #=> wrong number of arguments (1 for 3)
    # 
    #    b = proc { :foo }
    #    p b.curry[]                  #=> :foo
    def curry(*several_variants)
        #This is a stub, used for indexing
    end
    # prc.source_location  -> [String, Fixnum]
    #  
    # returns the ruby source filename and line number containing this proc
    # or nil if this proc was not defined in ruby (i.e. native)
    def source_location()
        #This is a stub, used for indexing
    end
    # proc.parameters  -> array
    #  
    # returns the parameter information of this proc.
    # 
    #    prc = lambda{|x, y=42, *rest|}
    #    prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :rest]]
    def parameters()
        #This is a stub, used for indexing
    end
end
